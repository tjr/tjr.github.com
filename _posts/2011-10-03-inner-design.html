---
layout: weblogentry
title: Inner Design
---

<p>
Contributing to an existing software engineering project can sometimes
feel more challenging than starting from scratch. We look at the code
that has already been written, and come to the conclusion that it is
hideous code implementing a poor design, and it would be better to
trash it all and do it the right way.

<p>
No doubt there really are a lot of poorly-done software projects, and
we really could do them better. But maybe sometimes the good design is
hidden by complexities that are simply unavoidable.

<p>
As a freshman studying calculus and physics, it's tempting to think
that the world is a stunningly mathematically beautiful place: motion
and speed and acceleration described so elegantly by functions and
derivatives! But in the real world, things aren't quite so pure. We
don't really have frictionless surfaces or massless objects. We have
to complicate those beautiful functions. The beauty is still there,
but it's not as obvious.

<p>
I think likewise, we can take a big-picture look at a software
project, and in our minds we see the unadulterated beautiful
design. We see the elegant solution to the problem. But when we
actually go to code it, try as we might, we can't stay entirely
elegant. There are edge cases that the elegance doesn't handle. There
are obstacles that we didn't account for, and now must work
around. There are requirements changes that come mid-stream and we
don't have time to start over. There are deficiencies in our own
understanding of our languages and libraries and compilers, and we
don't do everything in the most optimal way.

<p>
The result has a well-designed interior, but just like real-world
physics, there's a bunch of other stuff bolted on. And when an
outsider looks at the code, it's hard to see the beautiful inner
design amidst all of hacks.

