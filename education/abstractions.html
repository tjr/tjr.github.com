<html>
<head>
    <title>Abstractions</title>
    <link rel="stylesheet" href="/css/traditional.css" media="all" title="Default" charset="utf-8">
</head>

<body>
<div id="content">

<h1>Abstractions</h1>
<p>some reflections by <a href="/">Trevis Rothwell</a>, March 2013

<hr>

<a href="http://www.flickr.com/photos/trothwell/7984510853/"
title="IMG_8961 by trothwell, on
Flickr"><img src="http://farm9.staticflickr.com/8030/7984510853_0004ff1ee2_m.jpg"
width="240" height="160" alt="IMG_8961" align="right"
class="photo"></a>

<p>
Many things we do in life are built upon layers and layers of
abstractions. Sometimes these abstractions are so trivial that we
hardly notice them at all; in other cases they strike us as profound
revelation.

<p>
In computer programming, there are thousands of programming languages
to choose from. If you start learning how to program using Java, it
might seem like everything you learn about <i>programming</i> is
specific to <i>Java programming</i>. But after you've learned several
programming languages, you start to realize that much of what you
initially learned as Java programming was not specific to Java at all,
but was in fact a collection of abstract principles of software
development. The concepts of program structure, conditionals, looping,
variables &amp; state, et cetera, are common to many programming languages.
This makes learning an additional language a fairly trivial matter of
understanding which general concepts the language offers, and how to
use them in that language.

<p>
In music, there are hundreds of different instruments, but the
underlying knowledge of music theory and the skill to read musical
scores is essentially constant. As you learn your first instrument,
you are learning both the mechanics of that particular instrument, and
how to understand music theory and read scores. If you move on to a
second instrument, you're already half-way done before you start!  The
underlying concepts of music theory and score reading are portable,
and you only have to learn the mechanics of the new instrument.

<h2>Trivial Abstractions</h2>

<p>
You can find this same concept in many fields of work and study. In
fact, you can find this concept in areas of life that we might not
even consider "fields". When you learn how to drive a car, you don't
"learn how to drive a Honda Civic". You just learn how to drive, and
implicitly understand that once you learn how to drive one car, you
will be able to drive nearly any car without any more instruction.
You learn the abstractions of operating a car: starting the ignition,
using the gear shift, depressing the gas and brake pedals. These ideas
translate to any car, as well as to many other motorized vehicles.

<p>
Even something as trivial as picking up a book makes use of
abstractions. Maybe you've picked up a copy of <i>To Kill a
Mockingbird</i>, but have you ever picked up a copy of
<i>The Hobbit</i>? You probably could! You could surely also pick up a
VHS cassette, and a plate, and a sandwich. You use the same motor
skills to supersede the same laws of gravity no matter what you are
picking up.

<h2>Translating Abstractions</h2>

<p>
It would be absurd for someone to say, "Well, maybe you can pick up a
copy of <i>To Kill a Mockingbird</i>, but I am not sure you could pick
up a copy of <i>The Hobbit</i>." Somehow, though, as we climb up the
abstraction ladder into more specialized fields, it's not as obvious
when and how abstractions translate from one specific task to another.

<p>
Lots of software developers would vouch for their ability to learn a
new programming language quickly, because they already know a
half-dozen similar languages. Yet job postings often demand experience
in one particular language, ignoring altogether the fact that,
empowered with fundamental understanding of computer science, most
developers could become usefully productive in a new language within a
week or two.

<p>
But while a week or two is plenty for, say, a C++ programmer to become
productive in Java, since the two languages share many common ideas,
it might not be long enough for a C++ programmer become productive in
Ocaml, since the two languages are more divergent. Even so, many
common ideas remain, especially looking beyond language ideas into
general software engineering skills like planning, testing, and
revision control. How well and how quickly a C++ programmer could
become an Ocaml programmer depends on the individual's willingness to
learn.

<h2>Conclusion</h2>

<p>
Determining how well you can learn new specifics based on
previously-learned abstractions may not be an obvious process, but
realizing that what we know is based on layers of abstractions may be
a good start. Instead of thinking in terms of "Java programming" or
"C++ programming" or "Ocaml programming", we can think in terms of
which more abstract skills are portable and which are not.


<h2>References</h2>

<ul>
<li><a href="http://llk.media.mit.edu/courses/readings/Papert-Big-Idea.pdf">What's
the Big Idea? Toward a Pedagogy of Idea Power</a></li>
</ul>

<hr>
<i>
This was written as part of my participation in the MIT Media Lab
class on Learning Creative Learning, Spring 2013.

<hr>
<i><a href="mailto:tjr@acm.org">tjr@acm.org</a></i>

</div>
</body>
</html>
